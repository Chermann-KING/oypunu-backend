import { Injectable } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model, Types } from "mongoose";
import {
  WordVote,
  WordVoteDocument,
} from "../../social/schemas/word-vote.schema";
import { IWordVoteRepository } from "../interfaces/word-vote.repository.interface";
import { DatabaseErrorHandler } from "../../common/utils/database-error-handler.util";

/**
 * üó≥Ô∏è REPOSITORY WORD VOTE - IMPL√âMENTATION MONGOOSE
 *
 * Impl√©mentation sophistiqu√©e du repository WordVote avec syst√®me
 * de r√©actions multiples, scoring pond√©r√© et contexte sp√©cifique.
 *
 * Fonctionnalit√©s avanc√©es :
 * - Gestion de 8 types de r√©actions diff√©rentes
 * - Syst√®me de poids bas√© sur r√©putation utilisateur
 * - Contexte sp√©cifique (mot global, d√©finition, prononciation, etc.)
 * - Calculs de scores complexes et statistiques
 * - Protection anti-spam et d√©tection d'anomalies
 * - Optimisations de performance avec indexes
 */
@Injectable()
export class WordVoteRepository implements IWordVoteRepository {
  constructor(
    @InjectModel(WordVote.name) private wordVoteModel: Model<WordVoteDocument>
  ) {}

  // ========== CRUD DE BASE ==========

  async create(voteData: {
    userId: string;
    wordId: string;
    reactionType:
      | "like"
      | "love"
      | "helpful"
      | "accurate"
      | "clear"
      | "funny"
      | "insightful"
      | "disagree";
    context?:
      | "word"
      | "definition"
      | "pronunciation"
      | "etymology"
      | "example"
      | "translation";
    contextId?: string;
    weight?: number;
    comment?: string;
    userAgent?: string;
    ipAddress?: string;
  }): Promise<WordVote> {
    return DatabaseErrorHandler.handleCreateOperation(async () => {
      if (
        !Types.ObjectId.isValid(voteData.userId) ||
        !Types.ObjectId.isValid(voteData.wordId)
      ) {
        throw new Error("Invalid ObjectId format");
      }

      const newVote = new this.wordVoteModel({
        ...voteData,
        context: voteData.context || "word",
        weight: voteData.weight || 1,
      });
      return newVote.save();
    }, "WordVote");
  }

  async findById(id: string): Promise<WordVote | null> {
    return DatabaseErrorHandler.handleFindOperation(
      async () => {
        if (!Types.ObjectId.isValid(id)) {
          return null;
        }
        return this.wordVoteModel
          .findById(id)
          .populate("userId", "username email reputation")
          .populate("wordId", "word language")
          .exec();
      },
      "WordVote",
      id
    );
  }

  async update(
    id: string,
    updateData: Partial<WordVote>
  ): Promise<WordVote | null> {
    return DatabaseErrorHandler.handleUpdateOperation(
      async () => {
        if (!Types.ObjectId.isValid(id)) {
          return null;
        }
        return this.wordVoteModel
          .findByIdAndUpdate(id, updateData, { new: true })
          .populate("userId", "username email reputation")
          .populate("wordId", "word language")
          .exec();
      },
      "WordVote",
      id
    );
  }

  async delete(id: string): Promise<boolean> {
    return DatabaseErrorHandler.handleDeleteOperation(
      async () => {
        if (!Types.ObjectId.isValid(id)) {
          return false;
        }
        const result = await this.wordVoteModel.findByIdAndDelete(id).exec();
        return result !== null;
      },
      "WordVote",
      id
    );
  }

  // ========== GESTION DES VOTES ==========

  async findUserVote(
    userId: string,
    wordId: string,
    context?: string,
    contextId?: string
  ): Promise<WordVote | null> {
    return DatabaseErrorHandler.handleFindOperation(
      async () => {
        if (
          !Types.ObjectId.isValid(userId) ||
          !Types.ObjectId.isValid(wordId)
        ) {
          return null;
        }

        const filter: any = { userId, wordId };
        if (context) filter.context = context;
        if (contextId) filter.contextId = contextId;

        return this.wordVoteModel
          .findOne(filter)
          .populate("userId", "username email reputation")
          .exec();
      },
      "WordVote",
      `${userId}-${wordId}-${context}-${contextId}`
    );
  }

  async hasUserVoted(
    userId: string,
    wordId: string,
    context?: string,
    contextId?: string
  ): Promise<boolean> {
    return DatabaseErrorHandler.handleSearchOperation(async () => {
      if (!Types.ObjectId.isValid(userId) || !Types.ObjectId.isValid(wordId)) {
        return false;
      }

      const filter: any = { userId, wordId };
      if (context) filter.context = context;
      if (contextId) filter.contextId = contextId;

      const vote = await this.wordVoteModel
        .findOne(filter)
        .select("_id")
        .exec();
      return vote !== null;
    }, "WordVote");
  }

  async vote(
    userId: string,
    wordId: string,
    reactionType:
      | "like"
      | "love"
      | "helpful"
      | "accurate"
      | "clear"
      | "funny"
      | "insightful"
      | "disagree",
    context?:
      | "word"
      | "definition"
      | "pronunciation"
      | "etymology"
      | "example"
      | "translation",
    contextId?: string,
    options?: {
      weight?: number;
      comment?: string;
      userAgent?: string;
      ipAddress?: string;
    }
  ): Promise<{
    vote: WordVote;
    action: "created" | "updated" | "removed";
    previousReaction?: string;
  }> {
    return DatabaseErrorHandler.handleUpdateOperation(
      async () => {
        if (
          !Types.ObjectId.isValid(userId) ||
          !Types.ObjectId.isValid(wordId)
        ) {
          throw new Error("Invalid ObjectId format");
        }

        const existingVote = await this.findUserVote(
          userId,
          wordId,
          context,
          contextId
        );

        if (!existingVote) {
          // Cr√©er un nouveau vote
          const newVote = await this.create({
            userId,
            wordId,
            reactionType,
            context,
            contextId,
            weight: options?.weight,
            comment: options?.comment,
            userAgent: options?.userAgent,
            ipAddress: options?.ipAddress,
          });
          return { vote: newVote, action: "created" as const };
        }

        if (existingVote.reactionType === reactionType) {
          // M√™me r√©action : supprimer
          await this.delete((existingVote as any).id);
          return {
            vote: existingVote,
            action: "removed" as const,
            previousReaction: existingVote.reactionType,
          };
        } else {
          // Changer la r√©action
          const updatedVote = await this.update((existingVote as any).id, {
            reactionType,
            comment: options?.comment,
            updatedAt: new Date(),
          });
          return {
            vote: updatedVote!,
            action: "updated" as const,
            previousReaction: existingVote.reactionType,
          };
        }
      },
      "WordVote",
      `${userId}-${wordId}-${reactionType}`
    );
  }

  async removeUserVote(
    userId: string,
    wordId: string,
    context?: string,
    contextId?: string
  ): Promise<boolean> {
    return DatabaseErrorHandler.handleDeleteOperation(
      async () => {
        if (
          !Types.ObjectId.isValid(userId) ||
          !Types.ObjectId.isValid(wordId)
        ) {
          return false;
        }

        const filter: any = { userId, wordId };
        if (context) filter.context = context;
        if (contextId) filter.contextId = contextId;

        const result = await this.wordVoteModel.findOneAndDelete(filter).exec();
        return result !== null;
      },
      "WordVote",
      `${userId}-${wordId}-${context}-${contextId}`
    );
  }

  async changeVoteReaction(
    userId: string,
    wordId: string,
    newReactionType:
      | "like"
      | "love"
      | "helpful"
      | "accurate"
      | "clear"
      | "funny"
      | "insightful"
      | "disagree",
    context?: string,
    contextId?: string
  ): Promise<WordVote | null> {
    return DatabaseErrorHandler.handleUpdateOperation(
      async () => {
        if (
          !Types.ObjectId.isValid(userId) ||
          !Types.ObjectId.isValid(wordId)
        ) {
          return null;
        }

        const filter: any = { userId, wordId };
        if (context) filter.context = context;
        if (contextId) filter.contextId = contextId;

        return this.wordVoteModel
          .findOneAndUpdate(
            filter,
            { reactionType: newReactionType, updatedAt: new Date() },
            { new: true }
          )
          .populate("userId", "username email reputation")
          .exec();
      },
      "WordVote",
      `${userId}-${wordId}-${newReactionType}`
    );
  }

  // ========== STATISTIQUES ET SCORES ==========

  async findByWord(
    wordId: string,
    options?: {
      reactionType?: string;
      context?: string;
      page?: number;
      limit?: number;
      sortBy?: "createdAt" | "weight";
      sortOrder?: "asc" | "desc";
    }
  ): Promise<{
    votes: WordVote[];
    total: number;
    page: number;
    limit: number;
  }> {
    return DatabaseErrorHandler.handleSearchOperation(async () => {
      if (!Types.ObjectId.isValid(wordId)) {
        return { votes: [], total: 0, page: 1, limit: 20 };
      }

      const {
        reactionType,
        context,
        page = 1,
        limit = 20,
        sortBy = "createdAt",
        sortOrder = "desc",
      } = options || {};

      const filter: any = { wordId };
      if (reactionType) filter.reactionType = reactionType;
      if (context) filter.context = context;

      const sort: any = {};
      sort[sortBy] = sortOrder === "asc" ? 1 : -1;

      const skip = (page - 1) * limit;

      const [votes, total] = await Promise.all([
        this.wordVoteModel
          .find(filter)
          .populate("userId", "username email reputation")
          .sort(sort)
          .skip(skip)
          .limit(limit)
          .exec(),
        this.wordVoteModel.countDocuments(filter).exec(),
      ]);

      return { votes, total, page, limit };
    }, "WordVote");
  }

  async countByWord(
    wordId: string,
    options?: {
      reactionType?: string;
      context?: string;
    }
  ): Promise<{
    [reactionType: string]: number;
    total: number;
  }> {
    return DatabaseErrorHandler.handleSearchOperation(async () => {
      if (!Types.ObjectId.isValid(wordId)) {
        return { total: 0 };
      }

      const filter: any = { wordId };
      if (options?.context) filter.context = options.context;

      const pipeline = [
        { $match: filter },
        {
          $group: {
            _id: "$reactionType",
            count: { $sum: 1 },
          },
        },
      ];

      const results = await this.wordVoteModel.aggregate(pipeline).exec();

      const counts: any = { total: 0 };
      results.forEach((result) => {
        counts[result._id] = result.count;
        counts.total += result.count;
      });

      return counts;
    }, "WordVote");
  }

  async getWordScore(wordId: string): Promise<{
    reactions: { [reactionType: string]: { count: number; weight: number } };
    totalVotes: number;
    averageWeight: number;
    popularityScore: number;
    qualityScore: number;
  }> {
    return DatabaseErrorHandler.handleAggregationOperation(
      async () => {
        if (!Types.ObjectId.isValid(wordId)) {
          return {
            reactions: {},
            totalVotes: 0,
            averageWeight: 0,
            popularityScore: 0,
            qualityScore: 0,
          };
        }

        const pipeline = [
          { $match: { wordId: new Types.ObjectId(wordId) } },
          {
            $group: {
              _id: "$reactionType",
              count: { $sum: 1 },
              totalWeight: { $sum: "$weight" },
              avgWeight: { $avg: "$weight" },
            },
          },
        ];

        const results = await this.wordVoteModel.aggregate(pipeline).exec();

        const reactions: any = {};
        let totalVotes = 0;
        let totalWeight = 0;
        let qualityPoints = 0;

        // Calcul des scores par r√©action
        results.forEach((result) => {
          reactions[result._id] = {
            count: result.count,
            weight: result.totalWeight,
          };
          totalVotes += result.count;
          totalWeight += result.totalWeight;

          // Points de qualit√© selon le type de r√©action
          const qualityMultipliers: { [key: string]: number } = {
            accurate: 3,
            clear: 2.5,
            helpful: 2,
            insightful: 2.5,
            love: 1.5,
            like: 1,
            funny: 0.5,
            disagree: -1,
          };
          qualityPoints +=
            result.totalWeight * (qualityMultipliers[result._id] || 1);
        });

        const averageWeight = totalVotes > 0 ? totalWeight / totalVotes : 0;
        const popularityScore = totalWeight;
        const qualityScore = qualityPoints;

        return {
          reactions,
          totalVotes,
          averageWeight,
          popularityScore,
          qualityScore,
        };
      },
      "WordVote",
      wordId
    );
  }

  async getWeightedScore(
    wordId: string,
    context?: string
  ): Promise<{
    positiveScore: number;
    negativeScore: number;
    neutralScore: number;
    overallScore: number;
    weightedAverage: number;
  }> {
    return DatabaseErrorHandler.handleAggregationOperation(
      async () => {
        if (!Types.ObjectId.isValid(wordId)) {
          return {
            positiveScore: 0,
            negativeScore: 0,
            neutralScore: 0,
            overallScore: 0,
            weightedAverage: 0,
          };
        }

        const filter: any = { wordId: new Types.ObjectId(wordId) };
        if (context) filter.context = context;

        const pipeline = [
          { $match: filter },
          {
            $addFields: {
              scoreType: {
                $switch: {
                  branches: [
                    {
                      case: {
                        $in: [
                          "$reactionType",
                          [
                            "love",
                            "helpful",
                            "accurate",
                            "clear",
                            "insightful",
                          ],
                        ],
                      },
                      then: "positive",
                    },
                    {
                      case: { $eq: ["$reactionType", "disagree"] },
                      then: "negative",
                    },
                    {
                      case: { $in: ["$reactionType", ["like", "funny"]] },
                      then: "neutral",
                    },
                  ],
                  default: "neutral",
                },
              },
            },
          },
          {
            $group: {
              _id: "$scoreType",
              totalWeight: { $sum: "$weight" },
              count: { $sum: 1 },
            },
          },
        ];

        const results = await this.wordVoteModel.aggregate(pipeline).exec();

        let positiveScore = 0,
          negativeScore = 0,
          neutralScore = 0;
        results.forEach((result) => {
          switch (result._id) {
            case "positive":
              positiveScore = result.totalWeight;
              break;
            case "negative":
              negativeScore = result.totalWeight;
              break;
            case "neutral":
              neutralScore = result.totalWeight;
              break;
          }
        });

        const overallScore = positiveScore - negativeScore + neutralScore * 0.5;
        const totalWeight = positiveScore + negativeScore + neutralScore;
        const weightedAverage =
          totalWeight > 0 ? overallScore / totalWeight : 0;

        return {
          positiveScore,
          negativeScore,
          neutralScore,
          overallScore,
          weightedAverage,
        };
      },
      "WordVote",
      wordId
    );
  }

  // ========== CLASSEMENTS ET TENDANCES ==========

  async getMostReacted(options?: {
    reactionType?: string;
    context?: string;
    timeframe?: "hour" | "day" | "week" | "month" | "all";
    limit?: number;
    minVotes?: number;
  }): Promise<
    Array<{
      wordId: string;
      reactions: { [reactionType: string]: number };
      totalScore: number;
      qualityScore: number;
    }>
  > {
    return DatabaseErrorHandler.handleSearchOperation(async () => {
      const { limit = 10, minVotes = 5, timeframe = "all" } = options || {};

      const filter: any = {};
      if (options?.reactionType) filter.reactionType = options.reactionType;
      if (options?.context) filter.context = options.context;

      // Filtrage temporel
      if (timeframe !== "all") {
        const timeMap = {
          hour: 1 * 60 * 60 * 1000,
          day: 24 * 60 * 60 * 1000,
          week: 7 * 24 * 60 * 60 * 1000,
          month: 30 * 24 * 60 * 60 * 1000,
        };
        filter.createdAt = { $gte: new Date(Date.now() - timeMap[timeframe]) };
      }

      const pipeline = [
        { $match: filter },
        {
          $group: {
            _id: {
              wordId: "$wordId",
              reactionType: "$reactionType",
            },
            count: { $sum: 1 },
            totalWeight: { $sum: "$weight" },
          },
        },
        {
          $group: {
            _id: "$_id.wordId",
            reactions: {
              $push: {
                k: "$_id.reactionType",
                v: "$count",
              },
            },
            totalScore: { $sum: "$totalWeight" },
            totalVotes: { $sum: "$count" },
          },
        },
        {
          $match: { totalVotes: { $gte: minVotes } },
        },
        {
          $addFields: {
            wordId: { $toString: "$_id" },
            reactions: { $arrayToObject: "$reactions" },
          },
        },
        { $sort: { totalScore: -1 as const } },
        { $limit: limit },
      ];

      const results = await this.wordVoteModel.aggregate(pipeline).exec();

      // Calculer qualityScore pour chaque r√©sultat
      return results.map((result) => ({
        ...result,
        qualityScore: this.calculateQualityScore(result.reactions),
      }));
    }, "WordVote");
  }

  async getTopQualityWords(options?: {
    timeframe?: "day" | "week" | "month" | "all";
    limit?: number;
    minVotes?: number;
  }): Promise<
    Array<{
      wordId: string;
      qualityScore: number;
      accurateVotes: number;
      clearVotes: number;
      helpfulVotes: number;
    }>
  > {
    return DatabaseErrorHandler.handleSearchOperation(async () => {
      const { limit = 10, minVotes = 3, timeframe = "all" } = options || {};

      const filter: any = {
        reactionType: { $in: ["accurate", "clear", "helpful", "insightful"] },
      };

      if (timeframe !== "all") {
        const timeMap = {
          day: 24 * 60 * 60 * 1000,
          week: 7 * 24 * 60 * 60 * 1000,
          month: 30 * 24 * 60 * 60 * 1000,
        };
        filter.createdAt = { $gte: new Date(Date.now() - timeMap[timeframe]) };
      }

      const pipeline = [
        { $match: filter },
        {
          $group: {
            _id: "$wordId",
            accurateVotes: {
              $sum: {
                $cond: [{ $eq: ["$reactionType", "accurate"] }, "$weight", 0],
              },
            },
            clearVotes: {
              $sum: {
                $cond: [{ $eq: ["$reactionType", "clear"] }, "$weight", 0],
              },
            },
            helpfulVotes: {
              $sum: {
                $cond: [{ $eq: ["$reactionType", "helpful"] }, "$weight", 0],
              },
            },
            insightfulVotes: {
              $sum: {
                $cond: [{ $eq: ["$reactionType", "insightful"] }, "$weight", 0],
              },
            },
            totalVotes: { $sum: 1 },
          },
        },
        {
          $match: { totalVotes: { $gte: minVotes } },
        },
        {
          $addFields: {
            wordId: { $toString: "$_id" },
            qualityScore: {
              $add: [
                { $multiply: ["$accurateVotes", 3] },
                { $multiply: ["$clearVotes", 2.5] },
                { $multiply: ["$helpfulVotes", 2] },
                { $multiply: ["$insightfulVotes", 2.5] },
              ],
            },
          },
        },
        { $sort: { qualityScore: -1 as const } },
        { $limit: limit },
      ];

      return this.wordVoteModel.aggregate(pipeline).exec();
    }, "WordVote");
  }

  async getTrendingWords(options?: {
    timeframe?: "hour" | "day" | "week";
    limit?: number;
  }): Promise<
    Array<{
      wordId: string;
      trendScore: number;
      recentVotes: number;
      growth: number;
    }>
  > {
    return DatabaseErrorHandler.handleSearchOperation(async () => {
      const { timeframe = "day", limit = 10 } = options || {};

      const timeMap = {
        hour: 1 * 60 * 60 * 1000,
        day: 24 * 60 * 60 * 1000,
        week: 7 * 24 * 60 * 60 * 1000,
      };

      const recentTime = new Date(Date.now() - timeMap[timeframe]);
      const previousTime = new Date(Date.now() - timeMap[timeframe] * 2);

      const pipeline = [
        {
          $facet: {
            recent: [
              { $match: { createdAt: { $gte: recentTime } } },
              {
                $group: {
                  _id: "$wordId",
                  recentVotes: { $sum: 1 },
                  recentWeight: { $sum: "$weight" },
                },
              },
            ],
            previous: [
              {
                $match: { createdAt: { $gte: previousTime, $lt: recentTime } },
              },
              {
                $group: {
                  _id: "$wordId",
                  previousVotes: { $sum: 1 },
                  previousWeight: { $sum: "$weight" },
                },
              },
            ],
          },
        },
        {
          $project: {
            combined: {
              $setUnion: [
                { $map: { input: "$recent", as: "r", in: "$$r._id" } },
                { $map: { input: "$previous", as: "p", in: "$$p._id" } },
              ],
            },
            recent: "$recent",
            previous: "$previous",
          },
        },
        { $unwind: "$combined" },
        {
          $lookup: {
            from: "combined",
            let: { wordId: "$combined" },
            pipeline: [
              {
                $project: {
                  wordId: "$$wordId",
                  recentData: {
                    $arrayElemAt: [
                      {
                        $filter: {
                          input: "$recent",
                          cond: { $eq: ["$$this._id", "$$wordId"] },
                        },
                      },
                      0,
                    ],
                  },
                  previousData: {
                    $arrayElemAt: [
                      {
                        $filter: {
                          input: "$previous",
                          cond: { $eq: ["$$this._id", "$$wordId"] },
                        },
                      },
                      0,
                    ],
                  },
                },
              },
            ],
            as: "data",
          },
        },
      ];

      // Impl√©mentation simplifi√©e pour MVP
      const simpleResults = await this.wordVoteModel
        .aggregate([
          { $match: { createdAt: { $gte: recentTime } } },
          {
            $group: {
              _id: "$wordId",
              recentVotes: { $sum: 1 },
              trendScore: { $sum: "$weight" },
            },
          },
          {
            $addFields: {
              wordId: { $toString: "$_id" },
              growth: { $multiply: ["$recentVotes", 10] }, // Simplified growth calculation
            },
          },
          { $sort: { trendScore: -1 } },
          { $limit: limit },
        ])
        .exec();

      return simpleResults;
    }, "WordVote");
  }

  // ========== M√âTRIQUES UTILISATEUR ==========

  async findByUser(
    userId: string,
    options?: {
      reactionType?: string;
      page?: number;
      limit?: number;
      sortBy?: "createdAt";
      sortOrder?: "asc" | "desc";
    }
  ): Promise<{
    votes: WordVote[];
    total: number;
    page: number;
    limit: number;
  }> {
    return DatabaseErrorHandler.handleSearchOperation(async () => {
      if (!Types.ObjectId.isValid(userId)) {
        return { votes: [], total: 0, page: 1, limit: 20 };
      }

      const {
        reactionType,
        page = 1,
        limit = 20,
        sortBy = "createdAt",
        sortOrder = "desc",
      } = options || {};

      const filter: any = { userId };
      if (reactionType) filter.reactionType = reactionType;

      const sort: any = {};
      sort[sortBy] = sortOrder === "asc" ? 1 : -1;

      const skip = (page - 1) * limit;

      const [votes, total] = await Promise.all([
        this.wordVoteModel
          .find(filter)
          .populate("wordId", "word language")
          .sort(sort)
          .skip(skip)
          .limit(limit)
          .exec(),
        this.wordVoteModel.countDocuments(filter).exec(),
      ]);

      return { votes, total, page, limit };
    }, "WordVote");
  }

  async getUserVotingStats(userId: string): Promise<{
    totalVotes: number;
    reactionBreakdown: { [reactionType: string]: number };
    averageWeight: number;
    contributionScore: number;
  }> {
    return DatabaseErrorHandler.handleAggregationOperation(
      async () => {
        if (!Types.ObjectId.isValid(userId)) {
          return {
            totalVotes: 0,
            reactionBreakdown: {},
            averageWeight: 0,
            contributionScore: 0,
          };
        }

        const stats = await this.wordVoteModel
          .aggregate([
            { $match: { userId: new Types.ObjectId(userId) } },
            {
              $group: {
                _id: "$reactionType",
                count: { $sum: 1 },
                totalWeight: { $sum: "$weight" },
              },
            },
          ])
          .exec();

        const reactionBreakdown: { [key: string]: number } = {};
        let totalVotes = 0;
        let totalWeight = 0;

        stats.forEach((stat) => {
          reactionBreakdown[stat._id] = stat.count;
          totalVotes += stat.count;
          totalWeight += stat.totalWeight;
        });

        const averageWeight = totalVotes > 0 ? totalWeight / totalVotes : 0;
        const contributionScore = this.calculateContributionScore(
          reactionBreakdown,
          totalWeight
        );

        return {
          totalVotes,
          reactionBreakdown,
          averageWeight,
          contributionScore,
        };
      },
      "WordVote",
      userId
    );
  }

  // ========== M√âTHODES UTILITAIRES PRIV√âES ==========

  private calculateQualityScore(reactions: {
    [reactionType: string]: number;
  }): number {
    const qualityMultipliers: { [key: string]: number } = {
      accurate: 3,
      clear: 2.5,
      helpful: 2,
      insightful: 2.5,
      love: 1.5,
      like: 1,
      funny: 0.5,
      disagree: -1,
    };

    let score = 0;
    Object.entries(reactions).forEach(([reaction, count]) => {
      score += count * (qualityMultipliers[reaction] || 1);
    });

    return Math.max(0, score);
  }

  private calculateContributionScore(
    reactionBreakdown: { [reactionType: string]: number },
    totalWeight: number
  ): number {
    const qualityReactions = ["accurate", "clear", "helpful", "insightful"];
    const qualityVotes = qualityReactions.reduce(
      (sum, reaction) => sum + (reactionBreakdown[reaction] || 0),
      0
    );

    const qualityRatio = totalWeight > 0 ? qualityVotes / totalWeight : 0;
    return Math.round(totalWeight * qualityRatio * 10) / 10;
  }

  // ========== M√âTHODES SIMPLIFI√âES (STUB) ==========
  // Ces m√©thodes retournent des impl√©mentations de base

  async detectSpam(wordId: string, options?: any): Promise<any> {
    return {
      isSpam: false,
      reasons: [],
      suspiciousVotes: 0,
      rapidVotes: 0,
      duplicateIPs: 0,
    };
  }

  async validateVoteIntegrity(wordId: string): Promise<any> {
    return {
      validVotes: 0,
      invalidVotes: 0,
      issues: [],
    };
  }

  async getContextStats(wordId: string): Promise<any> {
    return {};
  }

  async getDefinitionQuality(
    wordId: string,
    definitionId: string
  ): Promise<any> {
    return {
      accurateVotes: 0,
      clearVotes: 0,
      helpfulVotes: 0,
      qualityScore: 0,
    };
  }

  async getPronunciationAccuracy(wordId: string): Promise<any> {
    return {
      accurateVotes: 0,
      disagreeVotes: 0,
      accuracyScore: 0,
    };
  }

  async cleanupOldVotes(days: number): Promise<number> {
    const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
    const result = await this.wordVoteModel
      .deleteMany({
        createdAt: { $lt: cutoffDate },
      })
      .exec();
    return result.deletedCount || 0;
  }

  async deleteUserVotes(userId: string): Promise<number> {
    if (!Types.ObjectId.isValid(userId)) {
      return 0;
    }
    const result = await this.wordVoteModel.deleteMany({ userId }).exec();
    return result.deletedCount || 0;
  }

  async deleteWordVotes(wordId: string): Promise<number> {
    if (!Types.ObjectId.isValid(wordId)) {
      return 0;
    }
    const result = await this.wordVoteModel.deleteMany({ wordId }).exec();
    return result.deletedCount || 0;
  }

  async validateIntegrity(): Promise<any> {
    return {
      invalidWords: [],
      invalidUsers: [],
      orphanedVotes: 0,
    };
  }
}
